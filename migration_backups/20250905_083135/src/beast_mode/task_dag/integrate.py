#!/usr/bin/env python3
"""
Beast Mode Framework - Task DAG Integration Script
Adds Task DAG capabilities to any spec directory
"""

import shutil
import sys
from pathlib import Path
import click


@click.command()
@click.argument('spec_path', type=click.Path(exists=True, file_okay=False, dir_okay=True))
@click.option('--force', is_flag=True, help='Overwrite existing files')
def integrate(spec_path, force):
    """
    Integrate Task DAG capabilities into a spec directory
    
    This will:
    1. Copy the Makefile template to the spec directory
    2. Create a task-dag wrapper script
    3. Validate that tasks.md exists
    """
    spec_path = Path(spec_path)
    
    click.echo(f"üîß Integrating Task DAG capabilities into: {spec_path}")
    
    # Check if tasks.md exists
    tasks_file = spec_path / "tasks.md"
    if not tasks_file.exists():
        click.echo(f"‚ùå No tasks.md found in {spec_path}")
        click.echo("   Task DAG requires a tasks.md file to analyze dependencies")
        sys.exit(1)
    
    # Get the template directory
    template_dir = Path(__file__).parent
    makefile_template = template_dir / "Makefile.template"
    
    if not makefile_template.exists():
        click.echo(f"‚ùå Makefile template not found: {makefile_template}")
        sys.exit(1)
    
    # Copy Makefile template
    target_makefile = spec_path / "Makefile.dag"
    
    if target_makefile.exists() and not force:
        click.echo(f"‚ö†Ô∏è  Makefile.dag already exists in {spec_path}")
        click.echo("   Use --force to overwrite")
    else:
        shutil.copy2(makefile_template, target_makefile)
        click.echo(f"‚úÖ Created: {target_makefile}")
    
    # Create task-dag wrapper script
    wrapper_script = spec_path / "task-dag"
    wrapper_content = f"""#!/bin/bash
# Task DAG wrapper script for {spec_path.name}
# Generated by Beast Mode Framework Task DAG integration

SPEC_PATH="{spec_path.absolute()}"
TASK_DAG_CLI="python3 -m beast_mode.task_dag.cli"

# Pass all arguments to the Task DAG CLI with spec path
$TASK_DAG_CLI --spec-path "$SPEC_PATH" "$@"
"""
    
    if wrapper_script.exists() and not force:
        click.echo(f"‚ö†Ô∏è  task-dag script already exists in {spec_path}")
        click.echo("   Use --force to overwrite")
    else:
        wrapper_script.write_text(wrapper_content)
        wrapper_script.chmod(0o755)  # Make executable
        click.echo(f"‚úÖ Created: {wrapper_script}")
    
    # Create integration instructions
    instructions_file = spec_path / "TASK_DAG_USAGE.md"
    instructions_content = f"""# Task DAG Usage for {spec_path.name}

This spec has been integrated with Beast Mode Framework Task DAG capabilities.

## Quick Start

### Using the wrapper script:
```bash
./task-dag analyze          # Analyze task dependencies
./task-dag execute --simulate  # Simulate task execution
./task-dag status           # Show current status
./task-dag task-info 1.1    # Show details for task 1.1
```

### Using the Makefile:
```bash
make -f Makefile.dag dag-analyze     # Analyze dependencies
make -f Makefile.dag dag-execute     # Execute with simulation
make -f Makefile.dag dag-status      # Show status
make -f Makefile.dag task-info TASK=1.1  # Show task details
```

### Using the CLI directly:
```bash
python3 -m beast_mode.task_dag.cli --spec-path . analyze
python3 -m beast_mode.task_dag.cli --spec-path . execute --simulate
```

## Available Commands

- `analyze` - Analyze task dependencies and create DAG
- `execute` - Execute tasks with recursive descent dependency resolution
- `status` - Show current task execution status
- `health` - Show Task DAG RM health status
- `list-tasks` - List all tasks with optional filtering
- `task-info <task_id>` - Show detailed information about a specific task

## Command Options

- `--dry-run` - Show execution plan without running (for execute command)
- `--simulate` - Simulate task completion for demonstration
- `--output <file>` - Specify output file for results
- `--tier <number>` - Filter tasks by tier (for list-tasks)
- `--status <status>` - Filter tasks by status (for list-tasks)

## Integration Details

- **Makefile**: `Makefile.dag` contains all Task DAG commands
- **Wrapper Script**: `task-dag` provides direct CLI access
- **Tasks File**: `tasks.md` is automatically parsed for dependencies
- **Output Files**: Analysis and execution results are saved as JSON

## Examples

```bash
# Analyze dependencies and export to custom file
./task-dag analyze --output my-analysis.json

# Execute with dry run first
./task-dag execute --dry-run
./task-dag execute --simulate

# List only ready tasks
./task-dag list-tasks --status not_started

# Show tasks in tier 0 (no dependencies)
./task-dag list-tasks --tier 0

# Get detailed info about a specific task
./task-dag task-info 2.1
```

## Makefile Integration

You can also include the Task DAG commands in your main Makefile:

```makefile
# Include Task DAG capabilities
include Makefile.dag

# Override spec name if needed
SPEC_NAME = {spec_path.name}
```

This allows you to use commands like:
```bash
make dag-analyze
make dag-execute
make task-info TASK=1.1
```
"""
    
    if instructions_file.exists() and not force:
        click.echo(f"‚ö†Ô∏è  TASK_DAG_USAGE.md already exists in {spec_path}")
        click.echo("   Use --force to overwrite")
    else:
        instructions_file.write_text(instructions_content)
        click.echo(f"‚úÖ Created: {instructions_file}")
    
    # Test the integration
    click.echo(f"\nüß™ Testing integration...")
    
    try:
        import sys
        import os
        sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))
        from beast_mode.task_dag.task_dag_rm import TaskDAGRM
        
        # Test loading tasks
        dag_rm = TaskDAGRM(str(spec_path))
        
        if dag_rm.tasks:
            click.echo(f"‚úÖ Successfully loaded {len(dag_rm.tasks)} tasks")
            
            # Show quick analysis
            analysis = dag_rm.analyze_dag()
            click.echo(f"   - {analysis.tier_count} tiers")
            click.echo(f"   - {analysis.max_parallelism} max parallel tasks")
            click.echo(f"   - {analysis.critical_path_length} critical path length")
        else:
            click.echo(f"‚ö†Ô∏è  No tasks loaded - check tasks.md format")
            
    except Exception as e:
        click.echo(f"‚ùå Integration test failed: {e}")
        sys.exit(1)
    
    click.echo(f"\nüéâ Task DAG integration complete!")
    click.echo(f"   Try: ./task-dag analyze")
    click.echo(f"   Or:  make -f Makefile.dag dag-analyze")


if __name__ == '__main__':
    integrate()